这是 **Go 调度器里非常容易被问深、也是区分“会背概念”和“真懂 runtime”** 的题。你给出的两个点是**正确方向**，我帮你**补全成一套“面试可直接输出”的完整答案**。

---

## 一、先给结论（面试先手）

> **Go 的抢占式调度经历了两个阶段：**
>
> * **Go 1.14 之前：基于协作式抢占**
> * **Go 1.14 之后：基于信号的异步抢占（真正的抢占式）**

---

## 二、Go 1.14 之前：基于「协作式抢占」

### 1️⃣ 什么是协作式抢占？

> **goroutine 不会被强行打断，只能在“安全点”主动让出 CPU**

也就是说：

* 调度器**不能随时打断 goroutine**
* 必须等 goroutine 自己配合

---

### 2️⃣ 安全点（safe point）在哪里？

典型安全点包括：

* 函数调用处
* channel 操作
* `select`
* `time.Sleep`
* `syscall`
* GC 检查点

❗ **问题点（面试官会追问）**

```go
for {
}
```

这个死循环：

* 没有函数调用
* 没有 IO
* 没有 channel
  ➡ **永远不会让出 CPU**

👉 会导致：

* 单 P 时，整个程序“假死”
* GC 无法及时执行

---

### 3️⃣ 协作式抢占的本质

> **不是“抢”，而是“你自己停一下”**

这也是 Go 早期被吐槽的地方。

---

## 三、Go 1.14+：基于「信号的异步抢占」（重点）

### 1️⃣ 为什么要引入真正抢占？

解决：

* 死循环不让出 CPU
* goroutine 饥饿
* GC Stop The World 不及时

---

### 2️⃣ 抢占是怎么做到的？（你提到的“信号量”，这里要纠正）

❗ **不是“信号量（semaphore）”**
✅ **是「操作系统信号（signal）」**

常见信号：

* Linux / macOS：`SIGURG`
* Windows：模拟中断

---

### 3️⃣ 抢占的核心流程（面试官最爱）

#### ① runtime 标记抢占

调度器发现：

* goroutine 运行太久
* 或 GC 需要 STW

```go
gp.preempt = true
```

---

#### ② 向 M 发送 OS 信号

```text
pthread_kill(M.thread, SIGURG)
```

➡ **中断正在运行的 goroutine**

---

#### ③ 信号处理函数执行

信号触发后：

* Go runtime 的 signal handler 被执行
* 检查当前是否在「可抢占点」

---

#### ④ 注入一个“伪函数调用”

编译器 + runtime 配合：

* 在函数序言中插入抢占检查
* 修改 PC，让 goroutine “跳转”到调度点

👉 表现效果：

> goroutine **在没有主动让出的情况下被暂停**

---

### 4️⃣ 这是不是 100% 强抢占？

❌ 不是

仍然 **无法在以下情况抢占**：

* 正在执行：

  * 系统调用
  * cgo
  * runtime critical section
* 在非安全的汇编代码中

👉 但 **已经足够应对死循环场景**

---

## 四、总结成一张对比表（面试杀器）

| 版本        | 抢占方式 | 特点                       |
| --------- | ---- | ------------------------ |
| Go ≤ 1.13 | 协作式  | 依赖 safe point，无法打断死循环    |
| Go ≥ 1.14 | 信号抢占 | OS signal 异步打断 goroutine |

---

## 五、面试标准答案模板（直接背）

> Go 的抢占式调度在 1.14 之前是基于协作式的，只能在安全点让出 CPU，无法打断纯计算型死循环。
> 从 Go 1.14 开始，引入了基于操作系统信号的异步抢占机制，runtime 会向正在运行的 M 发送信号，在信号处理函数中触发抢占，从而实现真正意义上的抢占式调度，但仍然只在安全点生效。

---

## 六、常见追问 & 一句话应对

### Q：为什么不能随时抢占？

> 为保证栈一致性和 GC 安全性，只能在可安全抢占点中断。

### Q：这和 Java 的抢占有什么不同？

> Java 是 OS 线程级抢占，Go 是 runtime 控制的用户态 goroutine 抢占。

---

如果你愿意，我可以继续帮你整理：

* 🔥 **GMP 调度模型完整执行链**
* 🔥 **为什么 Go 需要 P？**
* 🔥 **GOMAXPROCS 调度细节**
* 🔥 **Go 为什么不支持真正的实时调度？**

你这已经是 **字节 / 腾讯 / 美团 / 蚂蚁 P6+** 的题了 😎
